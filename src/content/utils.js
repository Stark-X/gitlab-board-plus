// GitLab Board Plus - Â∑•ÂÖ∑ÂáΩÊï∞
console.log('üîß GitLab Board Plus utils loaded');

// Áî®Êà∑‰ø°ÊÅØÂíåÊï∞ÊçÆÊèêÂèñÂ∑•ÂÖ∑Á±ª
if (typeof GitLabUtils === 'undefined') {
class GitLabUtils {
  // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑
  static getCurrentUser() {
    try {
      // Â∞ùËØï‰ªéÂ§ö‰∏™Âú∞ÊñπËé∑ÂèñÂΩìÂâçÁî®Êà∑‰ø°ÊÅØ
      let username = null;
      let avatarUrl = null;
      let name = null;
      
      // ÊñπÊ≥ï1: ‰ªéÈ°µÈù¢ÁöÑ gon ÂØπË±°Ëé∑ÂèñÔºàGitLab ÁöÑÂÖ®Â±ÄÂØπË±°Ôºâ
      if (window.gon && window.gon.current_username) {
        username = window.gon.current_username;
        name = window.gon.current_user_fullname || username;
        avatarUrl = window.gon.current_user_avatar_url;
        console.log(`‚úÖ Found current user from gon: ${username}`);
      }
      
      // ÊñπÊ≥ï2: ‰ªéÁî®Êà∑ËèúÂçïËé∑Âèñ
      if (!username) {
        const userMenu = document.querySelector('[data-qa-selector="user_menu"]') ||
                        document.querySelector('.header-user-dropdown-toggle') ||
                        document.querySelector('.user-menu') ||
                        document.querySelector('.navbar-nav .dropdown');
        
        if (userMenu) {
          // Â∞ùËØï‰ªéÁî®Êà∑Â§¥ÂÉèËé∑Âèñ‰ø°ÊÅØ
          const userImg = userMenu.querySelector('img');
          if (userImg) {
            avatarUrl = userImg.src;
            username = userImg.getAttribute('data-username') || 
                      userImg.getAttribute('data-user') ||
                      userImg.alt;
            name = userImg.getAttribute('title') || userImg.alt;
          }
          
          // Â∞ùËØï‰ªéÈìæÊé•hrefËé∑ÂèñÁî®Êà∑Âêç
          if (!username) {
            const userLink = userMenu.querySelector('a[href*="/"]');
            if (userLink) {
              const href = userLink.getAttribute('href');
              const userMatch = href.match(/\/([^\/]+)$/);
              if (userMatch && userMatch[1] && !userMatch[1].includes('.')) {
                username = userMatch[1];
                name = userLink.textContent.trim() || username;
              }
            }
          }
          
          if (username) {
            console.log(`‚úÖ Found current user from user menu: ${username}`);
          }
        }
      }
      
      // ÊñπÊ≥ï3: ‰ªéÈ°µÈù¢ÁöÑ data Â±ûÊÄßËé∑Âèñ
      if (!username) {
        const bodyData = document.body.dataset;
        if (bodyData.user || bodyData.username) {
          username = bodyData.user || bodyData.username;
          console.log(`‚úÖ Found current user from body data: ${username}`);
        }
      }
      
      // ÊñπÊ≥ï4: ‰ªé meta Ê†áÁ≠æËé∑Âèñ
      if (!username) {
        const userMeta = document.querySelector('meta[name="user-login"]') ||
                        document.querySelector('meta[name="current-user"]') ||
                        document.querySelector('meta[name="current-user-id"]');
        if (userMeta) {
          username = userMeta.getAttribute('content');
          console.log(`‚úÖ Found current user from meta: ${username}`);
        }
      }
      
      // ÊñπÊ≥ï5: ‰ªéÂΩìÂâçURLË∑ØÂæÑÂ∞ùËØïÊèêÂèñÔºàÂ¶ÇÊûúÂú®Áî®Êà∑profileÈ°µÈù¢Ôºâ
      if (!username) {
        const currentPath = window.location.pathname;
        if (currentPath.startsWith('/users/')) {
          const userMatch = currentPath.match(/\/users\/([^\/]+)/);
          if (userMatch && userMatch[1]) {
            username = userMatch[1];
            console.log(`‚úÖ Found current user from URL path: ${username}`);
          }
        }
      }
      
      if (username) {
        // ËøîÂõûÂÆåÊï¥ÁöÑÁî®Êà∑ÂØπË±°
        const userObj = {
          username,
          name: name || username,
          avatarUrl
        };
        
        // ‰∏∫‰∫ÜÂêëÂêéÂÖºÂÆπÔºåËÆæÁΩÆ‰∏Ä‰∏™usernameÂ±ûÊÄßÂà∞ËøîÂõûÂØπË±°‰∏ä
        userObj.toString = () => username;
        Object.defineProperty(userObj, 'valueOf', {
          value: () => username,
          enumerable: false
        });
        
        return userObj;
      }
      
      console.warn('‚ùå Could not determine current user from any source');
      return null;
    } catch (error) {
      console.error('‚ùå Error getting current user:', error);
      return null;
    }
  }

  // ‰ªéÈ°µÈù¢ÊèêÂèñÊàêÂëò‰ø°ÊÅØ
  static async extractMembersFromPage() {
    try {
      // ‰ΩøÁî®MapÊù•Â≠òÂÇ®ÊàêÂëò‰ø°ÊÅØÔºåÈÅøÂÖçSetÊó†Ê≥ïÊ≠£Á°ÆÂéªÈáçÂØπË±°ÁöÑÈóÆÈ¢ò
      const membersMap = new Map();
      
      // ÊñπÊ≥ï1: ‰ªéÂ∑≤ÊúâÁöÑissueÂç°Áâá‰∏≠ÊèêÂèñÊåáÊ¥æ‰∫∫‰ø°ÊÅØ
      const assigneeElements = document.querySelectorAll('[data-testid="assignee-avatar"], .board-card-assignee img, .assignee-avatar img');
      assigneeElements.forEach(el => {
        const username = el.getAttribute('data-username') || 
                        el.getAttribute('data-user-id') ||
                        el.getAttribute('alt')?.match(/@(\w+)/)?.[1];
        const name = el.getAttribute('alt') || el.getAttribute('title');
        if (username && !membersMap.has(username)) {
          membersMap.set(username, { username, name: name || username });
        }
      });
      
      // ÊñπÊ≥ï2: ‰ªéÁî®Êà∑Â§¥ÂÉèÂíåÈìæÊé•‰∏≠ÊèêÂèñ
      const userLinks = document.querySelectorAll('a[href*="/users/"], a[href*="/-/user/"]');
      userLinks.forEach(link => {
        const href = link.getAttribute('href');
        const match = href.match(/\/users\/([^\/\?]+)/);
        if (match) {
          const username = match[1];
          const name = link.textContent.trim() || link.getAttribute('title');
          if (!membersMap.has(username)) {
            membersMap.set(username, { username, name: name || username });
          }
        }
      });
      
      // ÊñπÊ≥ï3: ‰ªéGitLabÁöÑassignee dropdown‰∏≠ÊèêÂèñÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
      const assigneeOptions = document.querySelectorAll('[data-testid="assignee-dropdown"] .gl-dropdown-item, .assignee-dropdown .dropdown-item');
      assigneeOptions.forEach(option => {
        const username = option.getAttribute('data-username') || 
                        option.querySelector('[data-username]')?.getAttribute('data-username');
        const name = option.textContent.trim();
        if (username && !membersMap.has(username)) {
          membersMap.set(username, { username, name: name || username });
        }
      });
      
      const members = Array.from(membersMap.values());
      console.log(`‚úÖ Extracted ${members.length} members from page:`, members);
      
      return members;
      
    } catch (error) {
      console.error('‚ùå Error extracting members from page:', error);
      return [];
    }
  }

  // ‰ªéÈ°µÈù¢ÊèêÂèñÈáåÁ®ãÁ¢ë‰ø°ÊÅØ
  static async extractMilestonesFromPage() {
    try {
      const milestones = new Set();
      
      // ‰ªéissueÂç°Áâá‰∏≠ÊèêÂèñÈáåÁ®ãÁ¢ë‰ø°ÊÅØ
      const milestoneElements = document.querySelectorAll('[data-testid="milestone-title"], .milestone-title');
      milestoneElements.forEach(el => {
        const title = el.textContent.trim();
        if (title) {
          milestones.add({ id: title, title });
        }
      });
      
      return Array.from(milestones);
      
    } catch (error) {
      console.error('‚ùå Error extracting milestones from page:', error);
      return [];
    }
  }

  // ‰ªéÈ°µÈù¢ÊèêÂèñÊ†áÁ≠æ‰ø°ÊÅØ
  static async extractLabelsFromPage() {
    try {
      const labels = new Set();
      
      // ‰ªéissueÂç°Áâá‰∏≠ÊèêÂèñÊ†áÁ≠æ‰ø°ÊÅØ
      const labelElements = document.querySelectorAll('.label, [data-testid="label"]');
      labelElements.forEach(el => {
        const name = el.textContent.trim();
        const color = el.style.backgroundColor || el.getAttribute('data-color');
        if (name) {
          labels.add({ name, color });
        }
      });
      
      return Array.from(labels);
      
    } catch (error) {
      console.error('‚ùå Error extracting labels from page:', error);
      return [];
    }
  }

  // Ëé∑ÂèñÊêúÁ¥¢ËæìÂÖ•Ê°Ü
  static getSearchInput() {
    // Â∞ùËØïÂ§öÁßçÈÄâÊã©Âô®Êù•ÊâæÂà∞ÊêúÁ¥¢ËæìÂÖ•Ê°Ü
    const selectors = [
      '[data-testid="issue-board-filtered-search"] input',
      '.filtered-search-input-container input',
      '.filtered-search input',
      '.gl-filtered-search-input',
      'input[placeholder*="Search"]',
      'input[placeholder*="Filter"]'
    ];
    
    for (const selector of selectors) {
      const input = document.querySelector(selector);
      if (input) {
        console.log(`‚úÖ Found search input with selector: ${selector}`);
        return input;
      }
    }
    
    console.warn('‚ùå Search input not found');
    return null;
  }

  // Â∫îÁî®ÊêúÁ¥¢ËøáÊª§
  static applySearchFilter(searchInput, filterQuery) {
    try {
      console.log(`üîç Applying search filter: "${filterQuery}"`);
      
      // Ê∏ÖÁ©∫ÂΩìÂâçÊêúÁ¥¢ÂÜÖÂÆπ
      searchInput.value = '';
      
      // Ëß¶Âèë input ‰∫ã‰ª∂Ê∏ÖÁ©∫‰πãÂâçÁöÑÊêúÁ¥¢
      searchInput.dispatchEvent(new Event('input', { bubbles: true }));
      
      // Â¶ÇÊûúÊúâËøáÊª§Êü•ËØ¢ÔºåÂ∫îÁî®ÂÆÉ
      if (filterQuery) {
        // Âª∂Ëøü‰∏ÄÁÇπÊó∂Èó¥Á°Æ‰øùÊ∏ÖÁ©∫Êìç‰ΩúÂÆåÊàê
        setTimeout(() => {
          // ËÆæÁΩÆÊñ∞ÁöÑÊêúÁ¥¢ÂÄº
          searchInput.value = filterQuery;
          
          // Ëß¶ÂèëÂ§öÁßç‰∫ã‰ª∂Êù•Á°Æ‰øùÊêúÁ¥¢ÁîüÊïà
          searchInput.dispatchEvent(new Event('input', { bubbles: true }));
          searchInput.dispatchEvent(new Event('change', { bubbles: true }));
          
          // Ê®°ÊãüÊåâ Enter ÈîÆÊèê‰∫§ÊêúÁ¥¢
          setTimeout(() => {
            searchInput.dispatchEvent(new KeyboardEvent('keydown', { 
              key: 'Enter', 
              keyCode: 13, 
              bubbles: true 
            }));
            searchInput.dispatchEvent(new KeyboardEvent('keyup', { 
              key: 'Enter', 
              keyCode: 13, 
              bubbles: true 
            }));
          }, 100);
        }, 200);
      }
      
      console.log(`‚úÖ Search filter applied successfully`);
    } catch (error) {
      console.error('‚ùå Error applying search filter:', error);
    }
  }

  // ÊòæÁ§∫ËøáÊª§ÂèçÈ¶à
  static showFilterFeedback(filterQuery) {
    // Êü•ÊâæÊàñÂàõÂª∫ÂèçÈ¶àÂÖÉÁ¥†
    let feedback = document.querySelector('.filter-feedback');
    if (!feedback) {
      feedback = document.createElement('div');
      feedback.className = 'filter-feedback';
      
      // Â∞ÜÂèçÈ¶àÊèíÂÖ•Âà∞ÊêúÁ¥¢Âå∫Âüü
      const searchSection = document.querySelector('.gitlab-board-plus-search-section');
      if (searchSection) {
        searchSection.appendChild(feedback);
      }
    }
    
    // ËÆæÁΩÆÂèçÈ¶àÂÜÖÂÆπ
    if (filterQuery) {
      feedback.innerHTML = `
        <span class="feedback-icon">üîç</span>
        <span class="feedback-text">Â∑≤Â∫îÁî®ËøáÊª§: <strong>${filterQuery}</strong></span>
        <button class="feedback-close" onclick="this.parentElement.style.display='none'">√ó</button>
      `;
      feedback.style.display = 'flex';
      
      // 3ÁßíÂêéËá™Âä®ÈöêËóè
      setTimeout(() => {
        if (feedback) {
          feedback.style.display = 'none';
        }
      }, 3000);
    } else {
      feedback.innerHTML = `
        <span class="feedback-icon">‚ú®</span>
        <span class="feedback-text">Â∑≤Ê∏ÖÈô§ÊâÄÊúâËøáÊª§Êù°‰ª∂</span>
        <button class="feedback-close" onclick="this.parentElement.style.display='none'">√ó</button>
      `;
      feedback.style.display = 'flex';
      
      // 2ÁßíÂêéËá™Âä®ÈöêËóè
      setTimeout(() => {
        if (feedback) {
          feedback.style.display = 'none';
        }
      }, 2000);
    }
  }

  // Ê£ÄÊü•ÊòØÂê¶ÈÄæÊúü
  static isOverdue(card) {
    const dueDateElement = card.querySelector('.board-card-due-date');
    if (!dueDateElement) return false;
    
    const dueDate = new Date(dueDateElement.textContent);
    return dueDate < new Date();
  }

  // Ê∏ÖÈô§ËøáÊª§Áõ∏ÂÖ≥ÁöÑURLÂèÇÊï∞
  static clearFilterParams(url) {
    // GitLab boards È°µÈù¢Â∏∏Áî®ÁöÑËøáÊª§ÂèÇÊï∞
    const filterParams = [
      'assignee_username',
      'assignee_id', 
      'author_username',
      'author_id',
      'milestone_title',
      'label_name',
      'search',
      'state',
      'scope',
      'sort'
    ];
    
    filterParams.forEach(param => {
      url.searchParams.delete(param);
    });
  }

  // ÊèêÂèñÈ°πÁõÆ ID
  static extractProjectId() {
    const match = window.location.pathname.match(/^\/([^\/]+\/[^\/]+)/);
    return match ? match[1] : null;
  }

  // Ëé∑ÂèñÂΩìÂâç Board ID
  static getCurrentBoardId() {
    const match = window.location.pathname.match(/\/boards\/(\d+)/);
    return match ? match[1] : null;
  }

  // ÈÄöËøá GraphQL API Ëé∑ÂèñÈ°πÁõÆÊàêÂëò
  static async fetchProjectMembersFromAPI() {
    try {
      const projectId = this.extractProjectId();
      if (!projectId) {
        console.warn('‚ùå Could not extract project ID');
        return [];
      }

      const csrfToken = this.getCSRFToken();
      if (!csrfToken) {
        console.warn('‚ùå Could not get CSRF token');
        return [];
      }

      // ÊûÑÂª∫ GraphQL ËØ∑Ê±Ç
      const query = {
        operationName: "searchUsers",
        variables: {
          isProject: true,
          fullPath: projectId,
          search: ""
        },
        query: `query searchUsers($fullPath: ID!, $search: String, $isProject: Boolean = false) {
          group(fullPath: $fullPath) @skip(if: $isProject) {
            id
            groupMembers(
              search: $search
              relations: [DIRECT, INHERITED, SHARED_FROM_GROUPS]
            ) {
              nodes {
                id
                user {
                  ...User
                  __typename
                }
                __typename
              }
              __typename
            }
            __typename
          }
          project(fullPath: $fullPath) @include(if: $isProject) {
            id
            projectMembers(search: $search, relations: [DIRECT, INHERITED, INVITED_GROUPS]) {
              nodes {
                id
                user {
                  ...User
                  __typename
                }
                __typename
              }
              __typename
            }
            __typename
          }
        }

        fragment User on User {
          id
          avatarUrl
          name
          username
          __typename
        }`
      };

      // ÂèëÈÄÅ GraphQL ËØ∑Ê±Ç
      const response = await fetch(`${window.location.origin}/api/graphql`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify([query])
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (data[0]?.data?.project?.projectMembers?.nodes) {
        const members = data[0].data.project.projectMembers.nodes.map(node => ({
          id: node.user.id,
          username: node.user.username,
          name: node.user.name,
          avatarUrl: node.user.avatarUrl
        }));

        console.log(`‚úÖ Fetched ${members.length} project members from API:`, members);
        return members;
      } else {
        console.warn('‚ùå No project members data found in API response');
        return [];
      }

    } catch (error) {
      console.error('‚ùå Error fetching project members from API:', error);
      // Â¶ÇÊûú API Ë∞ÉÁî®Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞È°µÈù¢ÊèêÂèñÊñπÊ≥ï
      return this.extractMembersFromPage();
    }
  }

  // ÈÄöËøá GraphQL API Ëé∑ÂèñÈáåÁ®ãÁ¢ëÂàóË°®
  static async fetchMilestonesFromAPI() {
    try {
      const projectId = this.extractProjectId();
      if (!projectId) {
        console.warn('‚ùå Could not extract project ID');
        return [];
      }

      const csrfToken = this.getCSRFToken();
      if (!csrfToken) {
        console.warn('‚ùå Could not get CSRF token');
        return [];
      }

      // ÊûÑÂª∫ GraphQL ËØ∑Ê±Ç
      const query = {
        operationName: "searchMilestones",
        variables: {
          isProject: true,
          fullPath: projectId,
          search: ""
        },
        query: `query searchMilestones($fullPath: ID!, $search: String, $isProject: Boolean = false) {
          group(fullPath: $fullPath) @skip(if: $isProject) {
            id
            milestones(
              searchTitle: $search
              includeAncestors: true
              includeDescendants: true
              sort: EXPIRED_LAST_DUE_DATE_ASC
              state: active
            ) {
              nodes {
                ...Milestone
                __typename
              }
              __typename
            }
            __typename
          }
          project(fullPath: $fullPath) @include(if: $isProject) {
            id
            milestones(
              searchTitle: $search
              includeAncestors: true
              sort: EXPIRED_LAST_DUE_DATE_ASC
              state: active
            ) {
              nodes {
                ...Milestone
                __typename
              }
              __typename
            }
            __typename
          }
        }

        fragment Milestone on Milestone {
          id
          title
          __typename
        }`
      };

      // ÂèëÈÄÅ GraphQL ËØ∑Ê±Ç
      const response = await fetch(`${window.location.origin}/api/graphql`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify([query])
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (data[0]?.data?.project?.milestones?.nodes) {
        const milestones = data[0].data.project.milestones.nodes.map(node => ({
          id: node.id,
          title: node.title
        }));

        console.log(`‚úÖ Fetched ${milestones.length} milestones from API:`, milestones);
        return milestones;
      } else {
        console.warn('‚ùå No milestones data found in API response');
        return [];
      }

    } catch (error) {
      console.error('‚ùå Error fetching milestones from API:', error);
      // Â¶ÇÊûú API Ë∞ÉÁî®Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞È°µÈù¢ÊèêÂèñÊñπÊ≥ï
      return this.extractMilestonesFromPage();
    }
  }

  // ÈÄöËøá GraphQL API Ëé∑ÂèñÊ†áÁ≠æÂàóË°®
  static async fetchLabelsFromAPI() {
    try {
      const projectId = this.extractProjectId();
      if (!projectId) {
        console.warn('‚ùå Could not extract project ID');
        return [];
      }

      const csrfToken = this.getCSRFToken();
      if (!csrfToken) {
        console.warn('‚ùå Could not get CSRF token');
        return [];
      }

      // ÊûÑÂª∫ GraphQL ËØ∑Ê±Ç
      const query = {
        operationName: "searchLabels",
        variables: {
          isProject: true,
          fullPath: projectId,
          search: ""
        },
        query: `query searchLabels($fullPath: ID!, $search: String, $isProject: Boolean = false) {
          group(fullPath: $fullPath) @skip(if: $isProject) {
            id
            labels(
              searchTerm: $search
              includeAncestorGroups: true
              includeDescendantGroups: true
            ) {
              nodes {
                ...Label
              }
            }
            __typename
          }
          project(fullPath: $fullPath) @include(if: $isProject) {
            id
            labels(searchTerm: $search, includeAncestorGroups: true) {
              nodes {
                ...Label
              }
            }
            __typename
          }
        }

        fragment Label on Label {
          id
          color
          textColor
          title
          __typename
        }`
      };

      // ÂèëÈÄÅ GraphQL ËØ∑Ê±Ç
      const response = await fetch(`${window.location.origin}/api/graphql`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify([query])
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (data[0]?.data?.project?.labels?.nodes) {
        const labels = data[0].data.project.labels.nodes.map(node => ({
          id: node.id,
          title: node.title,
          color: node.color,
          textColor: node.textColor,
          name: node.title // ‰∏∫‰∫ÜÂÖºÂÆπÁé∞Êúâ‰ª£Á†ÅÔºåÊ∑ªÂä† name Â±ûÊÄß
        }));

        console.log(`‚úÖ Fetched ${labels.length} labels from API:`, labels);
        return labels;
      } else {
        console.warn('‚ùå No labels data found in API response');
        return [];
      }

    } catch (error) {
      console.error('‚ùå Error fetching labels from API:', error);
      // Â¶ÇÊûú API Ë∞ÉÁî®Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞È°µÈù¢ÊèêÂèñÊñπÊ≥ï
      return this.extractLabelsFromPage();
    }
  }

  // ÈÄöËøá Issues GraphQL API Ëé∑ÂèñÁî®Êà∑ÂàóË°®ÔºàÂàõÂª∫‰∫∫ÂíåÊåáÊ¥æ‰∫∫Ôºâ
  static async fetchUsersFromIssuesAPI() {
    try {
      console.log('üîç Fetching users from Issues API...');
      
      const projectId = this.extractProjectId();
      if (!projectId) {
        console.warn('‚ùå Could not extract project ID for Issues API');
        return [];
      }
      console.log(`üìÅ Project ID: ${projectId}`);

      const csrfToken = this.getCSRFToken();
      if (!csrfToken) {
        console.warn('‚ùå Could not get CSRF token for Issues API');
        return [];
      }

      // ÊûÑÂª∫ GraphQL ËØ∑Ê±Ç - ‰ΩøÁî®‰ºòÂåñÂêéÁöÑ issues Êü•ËØ¢ÔºåÂåÖÂê´ÈáåÁ®ãÁ¢ë‰ø°ÊÅØ
      const query = {
        operationName: "getIssues",
        variables: {
          isProject: true,
          fullPath: projectId,
          state: "opened",
          firstPageSize: 100,
          types: ["ISSUE"]
        },
        query: `query getIssues($isProject: Boolean = false, $fullPath: ID!, $state: IssuableState, $firstPageSize: Int, $types: [IssueType!]) {
          project(fullPath: $fullPath) @include(if: $isProject) {
            id
            issues(
              state: $state
              types: $types
              first: $firstPageSize
            ) {
              pageInfo {
                hasNextPage
                hasPreviousPage
                startCursor
                endCursor
                __typename
              }
              nodes {
                id
                iid
                title
                state
                assignees {
                  nodes {
                    id
                    name
                    username
                    avatarUrl
                    __typename
                  }
                  __typename
                }
                author {
                  id
                  name
                  username
                  avatarUrl
                  __typename
                }
                milestone {
                  id
                  title
                  __typename
                }
                __typename
              }
              __typename
            }
            __typename
          }
        }`
      };

      console.log('üì§ Sending Issues GraphQL request...');
      
      // ÂèëÈÄÅ GraphQL ËØ∑Ê±Ç
      const response = await fetch(`${window.location.origin}/api/graphql`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify([query])
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
      }

      const data = await response.json();
      console.log('üì• Issues API response received');
      
      // Ê£ÄÊü•ÂìçÂ∫îÁªìÊûÑ
      if (!data || !Array.isArray(data) || data.length === 0) {
        console.warn('‚ùå Invalid response structure from Issues API:', data);
        return [];
      }
      
      if (data[0]?.errors) {
        console.error('‚ùå GraphQL errors in Issues API response:', data[0].errors);
        return [];
      }
      
      if (data[0]?.data?.project?.issues?.nodes) {
        const issues = data[0].data.project.issues.nodes;
        console.log(`üìã Found ${issues.length} issues to process`);
        
        const usersMap = new Map();
        let authorCount = 0;
        let assigneeCount = 0;
        
        // ‰ªéÊâÄÊúâ issue ‰∏≠ÊèêÂèñÁî®Êà∑‰ø°ÊÅØ
        issues.forEach((issue, index) => {
          // Ê∑ªÂä†ÂàõÂª∫‰∫∫
          if (issue.author && issue.author.username) {
            const author = issue.author;
            if (!usersMap.has(author.username)) {
              usersMap.set(author.username, {
                id: author.id,
                username: author.username,
                name: author.name || author.username,
                avatarUrl: author.avatarUrl,
                isAuthor: true,
                isAssignee: false
              });
              authorCount++;
            } else {
              // Â¶ÇÊûúÁî®Êà∑Â∑≤Â≠òÂú®ÔºåÊ†áËÆ∞‰∏∫ÂàõÂª∫‰∫∫
              usersMap.get(author.username).isAuthor = true;
            }
          }
          
          // Ê∑ªÂä†ÊåáÊ¥æ‰∫∫
          if (issue.assignees && issue.assignees.nodes && Array.isArray(issue.assignees.nodes)) {
            issue.assignees.nodes.forEach(assignee => {
              if (assignee && assignee.username) {
                if (!usersMap.has(assignee.username)) {
                  usersMap.set(assignee.username, {
                    id: assignee.id,
                    username: assignee.username,
                    name: assignee.name || assignee.username,
                    avatarUrl: assignee.avatarUrl,
                    isAuthor: false,
                    isAssignee: true
                  });
                  assigneeCount++;
                } else {
                  // Â¶ÇÊûúÁî®Êà∑Â∑≤Â≠òÂú®ÔºåÊ†áËÆ∞‰∏∫ÊåáÊ¥æ‰∫∫
                  usersMap.get(assignee.username).isAssignee = true;
                }
              }
            });
          }
        });

        const users = Array.from(usersMap.values());
        const uniqueAuthors = users.filter(u => u.isAuthor).length;
        const uniqueAssignees = users.filter(u => u.isAssignee).length;
        const bothRoles = users.filter(u => u.isAuthor && u.isAssignee).length;
        
        console.log(`‚úÖ Successfully processed ${users.length} unique users from Issues API`);
        console.log(`üìä User statistics:
  - Unique authors: ${uniqueAuthors}
  - Unique assignees: ${uniqueAssignees}
  - Users with both roles: ${bothRoles}
  - Total processed issues: ${issues.length}`);
        
        return users;
      } else {
        console.warn('‚ùå No issues data found in API response structure');
        console.log('Response structure:', data[0]?.data);
        return [];
      }

    } catch (error) {
      console.error('‚ùå Error fetching users from Issues API:', error);
      console.log('üîÑ Falling back to project members API...');
      // Â¶ÇÊûú API Ë∞ÉÁî®Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞ÂéüÊúâÁöÑÊàêÂëòËé∑ÂèñÊñπÊ≥ï
      return this.fetchProjectMembersFromAPI();
    }
  }

  // ÈÄöËøá Issues GraphQL API Ëé∑ÂèñÁªüËÆ°Êï∞ÊçÆÔºàÊåáÊ¥æ‰∫∫„ÄÅÂàõÂª∫‰∫∫„ÄÅÈáåÁ®ãÁ¢ëÁöÑissueÊï∞ÈáèÔºâ
  static async fetchIssuesStatistics() {
    try {
      console.log('üìä Fetching issues statistics...');
      
      const projectId = this.extractProjectId();
      if (!projectId) {
        console.warn('‚ùå Could not extract project ID for statistics');
        return { assigneeStats: {}, authorStats: {}, milestoneStats: {} };
      }

      const csrfToken = this.getCSRFToken();
      if (!csrfToken) {
        console.warn('‚ùå Could not get CSRF token for statistics');
        return { assigneeStats: {}, authorStats: {}, milestoneStats: {} };
      }

      // ÊûÑÂª∫ GraphQL ËØ∑Ê±Ç - Ëé∑ÂèñÊâÄÊúâopenÁä∂ÊÄÅÁöÑissuesÂèäÂÖ∂Áõ∏ÂÖ≥‰ø°ÊÅØ
      const query = {
        operationName: "getIssuesForStats",
        variables: {
          isProject: true,
          fullPath: projectId,
          state: "opened",
          firstPageSize: 100,
          types: ["ISSUE"]
        },
        query: `query getIssuesForStats($isProject: Boolean = false, $fullPath: ID!, $state: IssuableState, $firstPageSize: Int, $types: [IssueType!]) {
          project(fullPath: $fullPath) @include(if: $isProject) {
            id
            issues(
              state: $state
              types: $types
              first: $firstPageSize
            ) {
              pageInfo {
                hasNextPage
                hasPreviousPage
                startCursor
                endCursor
                __typename
              }
              nodes {
                id
                iid
                title
                state
                assignees {
                  nodes {
                    id
                    name
                    username
                    avatarUrl
                    __typename
                  }
                  __typename
                }
                author {
                  id
                  name
                  username
                  avatarUrl
                  __typename
                }
                milestone {
                  id
                  title
                  __typename
                }
                __typename
              }
              __typename
            }
            __typename
          }
        }`
      };

      console.log('üì§ Sending Issues Statistics GraphQL request...');
      
      // ÂèëÈÄÅ GraphQL ËØ∑Ê±Ç
      const response = await fetch(`${window.location.origin}/api/graphql`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify([query])
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
      }

      const data = await response.json();
      console.log('üì• Issues Statistics API response received');
      
      // Ê£ÄÊü•ÂìçÂ∫îÁªìÊûÑ
      if (!data || !Array.isArray(data) || data.length === 0) {
        console.warn('‚ùå Invalid response structure from Issues Statistics API:', data);
        return { assigneeStats: {}, authorStats: {}, milestoneStats: {} };
      }
      
      if (data[0]?.errors) {
        console.error('‚ùå GraphQL errors in Issues Statistics API response:', data[0].errors);
        return { assigneeStats: {}, authorStats: {}, milestoneStats: {} };
      }
      
      if (data[0]?.data?.project?.issues?.nodes) {
        const issues = data[0].data.project.issues.nodes;
        console.log(`üìã Processing ${issues.length} issues for statistics`);
        
        const assigneeStats = {};
        const authorStats = {};
        const milestoneStats = {};
        
        // ÁªüËÆ°ÊØè‰∏™Áî®Êà∑ÂíåÈáåÁ®ãÁ¢ëÁöÑissueÊï∞Èáè
        issues.forEach(issue => {
          // ÁªüËÆ°ÂàõÂª∫‰∫∫
          if (issue.author && issue.author.username) {
            const username = issue.author.username;
            authorStats[username] = (authorStats[username] || 0) + 1;
          }
          
          // ÁªüËÆ°ÊåáÊ¥æ‰∫∫
          if (issue.assignees && issue.assignees.nodes && Array.isArray(issue.assignees.nodes)) {
            issue.assignees.nodes.forEach(assignee => {
              if (assignee && assignee.username) {
                const username = assignee.username;
                assigneeStats[username] = (assigneeStats[username] || 0) + 1;
              }
            });
          }
          
          // ÁªüËÆ°ÈáåÁ®ãÁ¢ë
          if (issue.milestone && issue.milestone.title) {
            const milestoneTitle = issue.milestone.title;
            milestoneStats[milestoneTitle] = (milestoneStats[milestoneTitle] || 0) + 1;
          }
        });
        
        console.log('üìä Statistics calculated:');
        console.log('  Assignee stats:', assigneeStats);
        console.log('  Author stats:', authorStats);
        console.log('  Milestone stats:', milestoneStats);
        
        return { assigneeStats, authorStats, milestoneStats };
      } else {
        console.warn('‚ùå No issues data found in statistics API response structure');
        return { assigneeStats: {}, authorStats: {}, milestoneStats: {} };
      }

    } catch (error) {
      console.error('‚ùå Error fetching issues statistics:', error);
      return { assigneeStats: {}, authorStats: {}, milestoneStats: {} };
    }
  }

  // Ëé∑Âèñ CSRF Token
  static getCSRFToken() {
    try {
      // ÊñπÊ≥ï1: ‰ªé meta Ê†áÁ≠æËé∑Âèñ
      const csrfMeta = document.querySelector('meta[name="csrf-token"]');
      if (csrfMeta) {
        const token = csrfMeta.getAttribute('content');
        console.log('‚úÖ Found CSRF token from meta tag');
        return token;
      }

      // ÊñπÊ≥ï2: ‰ªéÈ°µÈù¢ÁöÑ gon ÂØπË±°Ëé∑Âèñ
      if (window.gon && window.gon.api_token) {
        console.log('‚úÖ Found CSRF token from gon object');
        return window.gon.api_token;
      }

      // ÊñπÊ≥ï3: ‰ªéÁé∞ÊúâÁöÑ AJAX ËØ∑Ê±ÇÂ§¥‰∏≠Ëé∑Âèñ
      const ajaxSetup = window.jQuery && window.jQuery.ajaxSetup;
      if (ajaxSetup && ajaxSetup().headers && ajaxSetup().headers['X-CSRF-Token']) {
        console.log('‚úÖ Found CSRF token from jQuery AJAX setup');
        return ajaxSetup().headers['X-CSRF-Token'];
      }

      console.warn('‚ùå Could not find CSRF token from any source');
      return null;
    } catch (error) {
      console.error('‚ùå Error getting CSRF token:', error);
      return null;
    }
  }
  // ÊµãËØïÂáΩÊï∞ - Âú®ÊµèËßàÂô®ÊéßÂà∂Âè∞‰∏≠Ë∞ÉÁî®Êù•ÊµãËØïÊñ∞ÁöÑ Issues API
  static async testIssuesAPI() {
    console.log('üß™ Testing Issues API...');
    try {
      const users = await this.fetchUsersFromIssuesAPI();
      console.log('‚úÖ Issues API test completed');
      console.table(users);
      
      // ÂàÜÊûêÊï∞ÊçÆ
      const authors = users.filter(u => u.isAuthor);
      const assignees = users.filter(u => u.isAssignee);
      const both = users.filter(u => u.isAuthor && u.isAssignee);
      
      console.log(`üìä Summary:
- Total users: ${users.length}
- Authors only: ${authors.filter(u => !u.isAssignee).length}
- Assignees only: ${assignees.filter(u => !u.isAuthor).length}
- Both author and assignee: ${both.length}`);
      
      return users;
    } catch (error) {
      console.error('‚ùå Issues API test failed:', error);
      return [];
    }
  }
}

// ÂØºÂá∫Â∑•ÂÖ∑Á±ª
window.GitLabUtils = GitLabUtils;
} 